1.size returns a string::size_type value. This type is unsigned.Under the new standard, we can ask the compiler to provide the appropriate type by using auto or decltype:
	auto len = line.size(); // len has type string::size_type

2.string s7 = ("hello" + ", ") + s2; // error: can't add string literals 

3.Headers in C have names of the form name .h.The C++ versions of these headers are named c name—they remove the .h suffix and precede the name with the letter c. The c indicates that the header is part of the C library.Hence, cctype has the same contents as ctype.h, but in a form that is appropriate for C++ programs.

4. warning: range-based ‘for’ loops only available with -std=c++11 or -std=gnu++11.   Solution:
	#pragma GCC diagnostic error "-std=c++11" 
	or
	g++ -std=c++11 xxx.cpp -o  xxx

5.To use a vector, we must include the appropriate header.
	#include <vector>
	using std::vector;

6.In the past, we had to supply a space between the closing angle bracket of the outer vector and its element type  vector<vector<int> > rather than vector<vector<int>>.

7. vector<int> v1(10);    // v1 has ten elements with value 0
   vector<int> v2{10};    // v2 has one element  with value 10
   vector<int> v3(10, 1); // v3 has ten elements with value 1
   vector<int> v4{10, 1}; // v4 has two elements with values 10 and 1
   vector<string> svec(10); // ten elements, each an empty string
   vector<string> v5{"hi"}; // list initialization: v5 has one element
   vector<string> v6("hi"); // error: can't construct a vector from a string literal
   vector<string> v7{10};       // v7 has ten default-initialized elements
   vector<string> v8{10, "hi"}; // v8 has ten elements with value "hi"

8.   Sometimes we do not want to ignore the whitespace in our input. In  such cases, we can use the getline function instead of the >> operator.

    string line;
    // read input a line at a time until end-of-file
    while (getline(cin, line))
        cout << line << endl;

  Tip: short-cut for end-of-file :   ctrl + D  

9.The subscript operator on vector (and string) fetches an existing element; it does not add an element.To add an element, use V.push_back(x)
	
	vector<int> ivec;   // empty vector
	for (decltype(ivec.size()) ix = 0; ix != 10; ++ix)
	    ivec[ix] = ix;  // disaster: ivec has no elements

	for (decltype(ivec.size()) ix = 0; ix != 10; ++ix)
    	    ivec.push_back(ix);  // ok: adds a new element with value ix

	vector<int> ivec;      // empty vector
	cout << ivec[0];       // error: ivec has no elements!

10. auto b = v.begin(), e = v.end(); // b and e have the same type
    // the compiler determines the type of b and e; see § 2.5.2 (p. 68)
    // b denotes the first element and e denotes one past the last element in v
    // *(e-1) denotes the reference to the last element in v
    If the container is empty, begin returns the same iterator as the one returned by end.

11. standard container iterator operations
    *iter , iter->mem , ++iter , --iter , iter1!=iter2 , iter1==iter2 

12. By routinely using iterators and !=, we don’t have to worry about the precise type of container we’re processing, rather than iterator and subscripts.

13.  vector<int>::iterator it; // it can read and write vector<int> elements
     string::iterator it2;     // it2 can read and write characters in a string
     vector<int>::const_iterator it3; // it3 can read but not write elements
     string::const_iterator it4;      // it4 can read but not write characters

14. the library defines several other kinds of containers. All of the library containers have iterators, but only a few of them support the subscript operator. Technically speaking, a string is not a container type, but string supports many of the container operations. As we’ve seen string, like vector has a subscript operator. Like vectors, strings also have iterators.

15.it is usually best to use a const type (such as const_iterator) when we need to read but do not need to write to an object.To let us ask specifically for the const_iterator type, the new standard introduced two new functions named cbegin and cend:
	auto it3 = v.cbegin(); // it3 has type vector<int>::const_iterator

16. The arrow operator combines dereference and member access into a single operation. That is, it->mem is a synonym for (* it).mem  

17. it is important to realize that loops that use iterators should not add elements to the container to which the iterators refer. Any operation, such as push_back, that changes the size of a vector potentially invalidates all iterators into that vector.

18. If arrays are initialized from string literals, it is important to remember that string literals end with a null character.
	char a2[] = {'C', '+', '+', '\0'}; // list initialization, explicit null
	char a3[] = "C++";                 // null terminator added automatically
	const char a4[6] = "Daniel";       // error: no space for the null!
    The dimensions of a2 and a3 are both 4. The definition of a4 is in error. Although the literal contains only six explicit characters, the array size must be at least seven—six to hold the literal and one for the null.

19. Defining arrays that hold pointers is fairly straightforward, defining a pointer or reference to an array is a bit more complicated:
	int *ptrs[10];            //  ptrs is an array of ten pointers to int
	int &refs[10] = /* ? */;  //  error: no arrays of references
	int (*Parray)[10] = &arr; //  Parray points to an array of ten ints
	int (&arrRef)[10] = arr;  //  arrRef refers to an array of ten ints
	int *(&arry)[10] = ptrs;  //  arry is a reference to an array of ten pointers

20. size_t is a machine-specific unsigned type that is guaranteed to be large enough to hold the size of any object in memory. The size_t type is defined in the cstddef header.

21.	int *e = &arr[10]; // pointer just past the last element in arr

22. Arrays have functions begin and end ,which are defined in namespace std.
	using std::begin; using std::end;
	int ia[] = {0,1,2,3,4,5,6,7,8,9}; // ia is an array of ten ints
	int *beg = begin(ia); // pointer to the first element in ia
	int *last = end(ia);  // pointer one past the last element in ia

23. We cannot initialize a built-in array from another array. Nor can we initialize an array from a vector. However, we can use an array to initialize a vector. To do so, we specify the address of the first element and one past the last element that we wish to copy:
	int int_arr[] = {0, 1, 2, 3, 4, 5};
	// ivec has six elements; each is a copy of the corresponding element in int_arr
	vector<int> ivec(begin(int_arr), end(int_arr));
 As a result, ivec will have six elements.

24. Roughly speaking, when we use an object as an rvalue, we use the object’s value (its contents). When we use an object as an lvalue, we use the object’s identity (its location in memory).

25.  The precedence of postfix increment is higher than that of the dereference operator, so *pbeg++ is equivalent to *(pbeg++). The subexpression pbeg++ increments pbeg and yields a copy of the previous value of pbeg as its result.Accordingly, the operand of * is the unincremented value of pbeg. Thus, the statement prints the element to which pbeg originally pointed and increments pbeg.

26.  The Member Access Operators: The dot operator fetches a member from an object of class type; arrow is defined so that ptr -> mem is a synonym for (* ptr ). mem :
	string s1 = "a string", *p = &s1;
	auto n = s1.size(); // run the size member of the string s1
	n = (*p).size();    // run size on the object to which p points
	n = p->size();      // equivalent to (*p).size()
Because dereference has a lower precedence than dot, we must parenthesize the dereference subexpression.

27.  Because there are no guarantees for how the sign bit is handled, we strongly recommend using unsigned types with the bitwise operators.

28.   unsigned char bits = 0233  ; // 0233 is an octal literal.

29. The sizeof Operator : the operator takes one of two forms:
	sizeof (type)
	sizeof expr
 
	Sales_data data, *p;
	sizeof(Sales_data); // size required to hold an object of type Sales_data
	sizeof data; // size of data's type, i.e., sizeof(Sales_data)
	sizeof p;    // size of a pointer
	sizeof *p;   // size of the type to which p points, i.e., sizeof(Sales_data)
	sizeof data.revenue; // size of the type of Sales_data's revenue member
	sizeof Sales_data::revenue; // alternative way to get the size of revenue

30.  When the signedness differs and the type of the unsigned operand is the same as or larger than that of the signed operand, the signed operand is converted to unsigned. For example, given an unsigned int and an int, the int is converted to unsigned int.

31.   A continue statement terminates the current iteration of the nearest enclosing loop and immediately begins the next iteration. A continue can appear only inside a for, while, or do while loop.

32.   A goto statement provides an unconditional jump from the goto to a another statement in the same function. 
*************************
Programs should not use gotos. gotos make programs hard to understand and hard to modify.
*************************
The syntactic form of a goto statement is
 	goto label;
where label is an identifier that identifies a statement. A labeled statement is any
statement that is preceded by an identifier followed by a colon:
	end: return;  // labeled statement; may be the target of a goto

33.  throw expressions, which the detecting part uses to indicate that it encountered something it can’t handle. We say that a throw raises an exception.
	// first check that the data are for the same item
	if (item1.isbn() != item2.isbn())
 	   throw runtime_error("Data must refer to same ISBN");
	// if we're still here, the ISBNs are the same
	cout << item1 + item2 << endl;
Throwing an exception terminates the current function and transfers control to a handler that will know how to handle this error.

*The type runtime_error is one of the standard library exception types and is
defined in the stdexcept header.

	#include<stdexcept>
	using std::runtime_error;

34.  The try Block:  The general form of a try block is
 
	try {
 	   program-statements
	} catch (exception-declaration) {
	    handler-statements
	} catch (exception-declaration) {
	    handler-statements
	} // . . .

    Following the try block is a list of one or more catch clauses. A catch consists of three parts: the keyword catch, the declaration of a (possibly unnamed) object within parentheses (referred to as an exception declaration), and a block.When a
catch is selected to handle an exception, the associated block is executed. Once the
catch finishes, execution continues with the statement immediately following the last
catch clause of the try block.

35.  A function definition typically consists of a return type , a name, a list of zero or more parameters, and a body. The parameters are specified in a comma-separated list enclosed in parentheses. The actions that the function performs are specified in a statement block, referred to as the function body .

36.  if(!strcmp(str1,str2)) {...}
     strcmp() return value:
	<0	the first character has a lower value in ptr1 than in ptr2
	0	the contents of both strings are equal
	>0	the first character has a greater value in ptr1 than in ptr2

37.  Use the C++ stringstream class to convert the third command line argument from text to an integer format. 

	#include <sstream>
	...
	int divideWith = 0; // convert our input string to number - C++ style
	stringstream s;
	s << argv[2];
	s >> divideWith;

38.  A parameter list typically consists of a comma-separated list of parameters, each of
which looks like a declaration with a single declarator. Even when the types of two
parameters are the same, the type must be repeated:

	int f3(int v1, v2) { /* ... */ }     // error
	int f4(int v1, int v2) { /* ... */ } // ok

39.  However, the return type may not be an array type or a function type. However, a function may return a pointer to an array or a function.

40.  Objects that exist only while a block is executing are known as automatic objects. After execution exits a block, the values of the automatic objects created in that block are undefined. Or in other words, the objects are destoryed.  Parameters are automatic objects.

41.  Local static object is initialized before the first time execution passes through the object’s definition. Local statics are not destroyed when a function ends; they are destroyed when the program terminates.

	size_t count_calls()
	{
	    static size_t ctr = 0;  // value will persist across calls
 	   return ++ctr;
	}
	int main()
	{
	    for (size_t i = 0; i != 10; ++i)
 	       cout << count_calls() << endl;
  	  return 0;
	}
    This program will print the numbers from 1 through 10 inclusive.
    Before control flows through the definition of ctr for the first time, ctr is created
and given an initial value of 0. Each call increments ctr and returns its new value. Whenever count_calls is executed, the variable ctr already exists and has whatever value was in that variable the last time the function exited. Thus, on the second invocation, the value of ctr is 1, on the third it is 2, and so on.

    If a local static has no explicit initializer, it is value initialized, meaning that local statics of built-in type are initialized to zero.

42.  Because a function declaration has no body, there is no need for parameter names. Hence, parameter names are often omitted in a declaration. But they can be useful to remind users what the function does.

// parameter names chosen to indicate that the iterators denote a range of values to print
	   void print(vector<int>::const_iterator beg,
           vector<int>::const_iterator end);

     These three elements—the return type, function name, and parameter types—describe
the function’s interface.
































	
